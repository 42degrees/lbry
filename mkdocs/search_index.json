{
    "docs": [
        {
            "location": "/", 
            "text": "LBRY JSON-RPC API Documentation\n\n\nblob_announce_all\n\n\nAnnounce all blobs to the DHT\n\nArgs:\n    None\nReturns:\n    (str) Success/fail message\n\n\n\n\nblob_delete\n\n\nDelete a blob\n\nArgs:\n    'blob_hash': (str) hash of blob to get\nReturns:\n    (str) Success/fail message\n\n\n\n\nblob_get\n\n\nDownload and return a blob\n\nArgs:\n    'blob_hash': (str) blob hash of blob to get\n    'timeout'(optional): (int) timeout in number of seconds\n    'encoding'(optional): (str) by default no attempt at decoding is made,\n                         can be set to one of the following decoders:\n                         'json'\n    'payment_rate_manager'(optional): if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     'only-free'\n\nReturns\n    (str) Success/Fail message or (dict) decoded data\n\n\n\n\nblob_list\n\n\nReturns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nArgs:\n    'uri' (optional): (str) filter by blobs in stream for winning claim\n    'stream_hash' (optional): (str) filter by blobs in given stream hash\n    'sd_hash' (optional): (str) filter by blobs in given sd hash\n    'needed' (optional): (bool) only return needed blobs\n    'finished' (optional): (bool) only return finished blobs\n    'page_size' (optional): (int) limit number of results returned\n    'page' (optional): (int) filter to page x of [page_size] results\nReturns:\n    (list) List of blob hashes\n\n\n\n\nblob_reflect_all\n\n\nReflects all saved blobs\n\nArgs:\n    None\nReturns:\n    (bool) true if successful\n\n\n\n\nblock_show\n\n\nGet contents of a block\n\nArgs:\n    'blockhash': (str) hash of the block to look up\nReturns:\n    (dict) Requested block\n\n\n\n\nchannel_list_mine\n\n\nGet my channels\n\nReturns:\n    (list) ClaimDict\n\n\n\n\nchannel_new\n\n\nGenerate a publisher key and create a new certificate claim\n\nArgs:\n    'channel_name': (str) '@' prefixed name\n    'amount': (float) amount to claim name\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nclaim_abandon\n\n\nAbandon a name and reclaim credits from the claim\n\nArgs:\n    'claim_id': (str) claim_id of claim\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_list\n\n\nGet claims for a name\n\nArgs:\n    'name': (str) search for claims on this name\nReturns\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }\n\n\n\n\nclaim_list_mine\n\n\nList my name claims\n\nArgs:\n    None\nReturns\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str) \nclaim\n, \nupdate\n , or \nsupport\n\n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'txid': (str) txid of the cliam\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]\n\n\n\n\nclaim_new_support\n\n\nSupport a name claim\n\nArgs:\n    'name': (str) Name of claim\n    'claim_id': (str) claim ID of claim to support\n    'amount': (float) amount to support by\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_show\n\n\nResolve claim info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\n    'txid'(optional): (str) if specified, look for claim with this txid\n    'nout'(optional): (int) if specified, look for claim with this nout\n    'claim_id'(optional): (str) if specified, look for claim with this claim_id\nReturns:\n    (dict) Dictionary containing claim info, (bool) false if claim is not\n        resolvable\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n\n\n\ncommands\n\n\nReturn a list of available commands\n\nReturns:\n    (list) list of available commands\n\n\n\n\ndaemon_stop\n\n\nStop lbrynet-daemon\n\nReturns:\n    (string) Shutdown message\n\n\n\n\ndescriptor_get\n\n\nDownload and return a sd blob\n\nArgs:\n    'sd_hash': (str) hash of sd blob\n    'timeout'(optional): (int) timeout in number of seconds\n    'payment_rate_manager'(optional): (str) if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     only-free\n\nReturns\n    (str) Success/Fail message or (dict) decoded data\n\n\n\n\nfile_delete\n\n\nDelete a lbry file\n\nArgs:\n    'name' (optional): (str) delete file by lbry name,\n    'sd_hash' (optional): (str) delete file by sd hash,\n    'file_name' (optional): (str) delete file by the name in the downloads folder,\n    'stream_hash' (optional): (str) delete file by stream hash,\n    'claim_id' (optional): (str) delete file by claim ID,\n    'outpoint' (optional): (str) delete file by claim outpoint,\n    'rowid': (optional): (int) delete file by rowid in the file manager\n    'delete_target_file' (optional): (bool) delete file from downloads folder,\n                                    defaults to true if false only the blobs and\n                                    db entries will be deleted\nReturns:\n    (bool) true if deletion was successful\n\n\n\n\nfile_list\n\n\nList files limited by optional filters\n\nArgs:\n    'name' (optional): (str) filter files by lbry name,\n    'sd_hash' (optional): (str) filter files by sd hash,\n    'file_name' (optional): (str) filter files by the name in the downloads folder,\n    'stream_hash' (optional): (str) filter files by stream hash,\n    'claim_id' (optional): (str) filter files by claim id,\n    'outpoint' (optional): (str) filter files by claim outpoint,\n    'rowid' (optional): (int) filter files by internal row id,\n    'full_status': (optional): (bool) if true populate the 'message' and 'size' fields\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'name': (str) name claim attached to file\n            'outpoint': (str) claim outpoint attached to file\n            'claim_id': (str) claim ID attached to file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false\n            'written_bytes': (int) written size in bytes\n            'message': (str), None if full_status is false\n            'metadata': (dict) Metadata dictionary\n        },\n    ]\n\n\n\n\nfile_set_status\n\n\nStart or stop downloading a file\n\nArgs:\n    'status': (str) \nstart\n or \nstop\n\n    'name' (optional): (str) start file by lbry name,\n    'sd_hash' (optional): (str) start file by the hash in the name claim,\n    'file_name' (optional): (str) start file by its name in the downloads folder,\nReturns:\n    (str) Confirmation message\n\n\n\n\nget\n\n\nDownload stream from a LBRY name.\n\nArgs:\n    'uri': (str) lbry uri to download\n    'file_name'(optional): (str) a user specified name for the downloaded file\n    'timeout'(optional): (int) download timeout in number of seconds\n    'download_directory'(optional): (str) path to directory where file will be saved\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'name': (str) name claim attached to file\n        'outpoint': (str) claim outpoint attached to file\n        'claim_id': (str) claim ID attached to file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false\n        'written_bytes': (int) written size in bytes\n        'message': (str), None if full_status is false\n        'metadata': (dict) Metadata dictionary\n    }\n\n\n\n\nget_availability\n\n\nGet stream availability for lbry uri\n\nArgs:\n    'uri' : (str) lbry uri\n    'sd_timeout' (optional): (int) sd blob download timeout\n    'peer_timeout' (optional): (int) how long to look for peers\n\nReturns:\n    (float) Peers per blob / total blobs\n\n\n\n\nhelp\n\n\nReturn a useful message for an API command\n\nArgs:\n    'command'(optional): (str) command to retrieve documentation for\nReturns:\n    (str) if given a command, returns documentation about that command\n    otherwise returns general help message\n\n\n\n\npeer_list\n\n\nGet peers for blob hash\n\nArgs:\n    'blob_hash': (str) blob hash\n    'timeout'(optional): (int) peer search timeout in seconds\nReturns:\n    (list) List of contacts\n\n\n\n\npublish\n\n\nMake a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license',\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nArgs:\n    'name': (str) name to be claimed\n    'bid': (float) amount of credits to commit in this claim,\n    'metadata'(optional): (dict) Metadata to associate with the claim.\n    'file_path'(optional): (str) path to file to be associated with name. If provided,\n                            a lbry stream of this file will be used in 'sources'.\n                            If no path is given but a metadata dict is provided, the source\n                            from the given metadata will be used.\n    'fee'(optional): (dict) Dictionary representing key fee to download content:\n                      {currency_symbol: {'amount': float, 'address': str, optional}}\n                      supported currencies: LBC, USD, BTC\n                      If an address is not provided a new one will be automatically\n                      generated. Default fee is zero.\n    'title'(optional): (str) title of the file\n    'description'(optional): (str) description of the file\n    'author'(optional): (str) author of the file\n    'language'(optional): (str), language code\n    'license'(optional): (str) license for the file\n    'license_url'(optional): (str) URL to license\n    'thumbnail'(optional): (str) thumbnail URL for the file\n    'preview'(optional): (str) preview URL for the file\n    'nsfw'(optional): (bool) True if not safe for work\n    'sources'(optional): (dict){'lbry_sd_hash':sd_hash} specifies sd hash of file\n    'channel_name' (optional): (str) name of the publisher channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nreflect\n\n\nReflect a stream\n\nArgs:\n    'sd_hash': (str) sd_hash of lbry file\nReturns:\n    (bool) true if successful\n\n\n\n\nreport_bug\n\n\nReport a bug to slack\n\nArgs:\n    'message': (str) message to send\nReturns:\n    (bool) true if successful\n\n\n\n\nresolve\n\n\nResolve a LBRY URI\n\nArgs:\n    'uri': (str) uri to download\nReturns:\n    None if nothing can be resolved, otherwise:\n    If uri resolves to a channel or a claim in a channel:\n        'certificate': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}],\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    If uri resolves to a channel:\n        'claims_in_channel': [\n            {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'supports: (list) list of supports [{'txid': txid,\n                                                     'nout': nout,\n                                                     'amount': amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n        ]\n    If uri resolves to a claim:\n        'claim': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'channel_name': (str) channel name if claim is in a channel\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}]\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    }\n\n\n\n\nresolve_name\n\n\nResolve stream info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable\n\n\n\n\nsend_amount_to_address\n\n\nSend credits to an address\n\nArgs:\n    'amount': (float) the amount to send\n    'address': (str) the address of the recipient in base58\nReturns:\n    (bool) true if payment successfully scheduled\n\n\n\n\nsettings_get\n\n\nGet daemon settings\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings\n\n\n\n\nsettings_set\n\n\nSet daemon settings\n\nArgs:\n    'run_on_startup': (bool) currently not supported\n    'data_rate': (float) data rate,\n    'max_key_fee': (float) maximum key fee,\n    'disable_max_key_fee': (bool) true to disable max_key_fee check,\n    'download_directory': (str) path of where files are downloaded,\n    'peer_port': (int) port through which daemon should connect,\n    'max_upload': (float), currently not supported\n    'max_download': (float), currently not supported\n    'download_timeout': (int) download timeout in seconds\n    'search_timeout': (float) search timeout in seconds\n    'cache_time': (int) cache timeout in seconds\nReturns:\n    (dict) Updated dictionary of daemon settings\n\n\n\n\nstatus\n\n\nReturn daemon status\n\nArgs:\n    'session_status' (optional): (bool) true to return session status,\n        default is false\nReturns:\n    (dict) Daemon status dictionary\n\n\n\n\nstream_cost_estimate\n\n\nGet estimated cost for a lbry stream\n\nArgs:\n    'name': (str) lbry name\n    'size' (optional): (int) stream size, in bytes. if provided an sd blob\n                        won't be downloaded.\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolveable\n\n\n\n\ntransaction_list\n\n\nList transactions belonging to wallet\n\nArgs:\n    None\nReturns:\n    (list) List of transactions\n\n\n\n\ntransaction_show\n\n\nGet a decoded transaction from a txid\n\nArgs:\n    'txid': (str) txid of transaction\nReturns:\n    (dict) JSON formatted transaction\n\n\n\n\nversion\n\n\nGet lbry version information\n\nArgs:\n    None\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g. \ndev\n, \nrc\n, \nrelease\n),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }\n\n\n\n\nwallet_balance\n\n\nReturn the balance of the wallet\n\nArgs:\n    'address' (optional): If address is provided only that balance will be given\n    'include_unconfirmed' (optional): If set unconfirmed balance will be included in\n     the only takes effect when address is also provided.\n\nReturns:\n    (float) amount of lbry credits in wallet\n\n\n\n\nwallet_is_address_mine\n\n\nChecks if an address is associated with the current wallet.\n\nArgs:\n    'address': (str) address to check in base58\nReturns:\n    (bool) true, if address is associated with current wallet\n\n\n\n\nwallet_list\n\n\nList wallet addresses\n\nArgs:\n    None\nReturns:\n    List of wallet addresses\n\n\n\n\nwallet_new_address\n\n\nGenerate a new wallet address\n\nArgs:\n    None\nReturns:\n    (str) New wallet address in base58\n\n\n\n\nwallet_public_key\n\n\nGet public key from wallet address\n\nArgs:\n    'address': (str) wallet address in base58\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.\n\n\n\n\nwallet_unused_address\n\n\nReturn an address containing no balance, will create\na new address if there is none.\n\nArgs:\n    None\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "API"
        }, 
        {
            "location": "/#lbry-json-rpc-api-documentation", 
            "text": "", 
            "title": "LBRY JSON-RPC API Documentation"
        }, 
        {
            "location": "/#blob_announce_all", 
            "text": "Announce all blobs to the DHT\n\nArgs:\n    None\nReturns:\n    (str) Success/fail message", 
            "title": "blob_announce_all"
        }, 
        {
            "location": "/#blob_delete", 
            "text": "Delete a blob\n\nArgs:\n    'blob_hash': (str) hash of blob to get\nReturns:\n    (str) Success/fail message", 
            "title": "blob_delete"
        }, 
        {
            "location": "/#blob_get", 
            "text": "Download and return a blob\n\nArgs:\n    'blob_hash': (str) blob hash of blob to get\n    'timeout'(optional): (int) timeout in number of seconds\n    'encoding'(optional): (str) by default no attempt at decoding is made,\n                         can be set to one of the following decoders:\n                         'json'\n    'payment_rate_manager'(optional): if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     'only-free'\n\nReturns\n    (str) Success/Fail message or (dict) decoded data", 
            "title": "blob_get"
        }, 
        {
            "location": "/#blob_list", 
            "text": "Returns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nArgs:\n    'uri' (optional): (str) filter by blobs in stream for winning claim\n    'stream_hash' (optional): (str) filter by blobs in given stream hash\n    'sd_hash' (optional): (str) filter by blobs in given sd hash\n    'needed' (optional): (bool) only return needed blobs\n    'finished' (optional): (bool) only return finished blobs\n    'page_size' (optional): (int) limit number of results returned\n    'page' (optional): (int) filter to page x of [page_size] results\nReturns:\n    (list) List of blob hashes", 
            "title": "blob_list"
        }, 
        {
            "location": "/#blob_reflect_all", 
            "text": "Reflects all saved blobs\n\nArgs:\n    None\nReturns:\n    (bool) true if successful", 
            "title": "blob_reflect_all"
        }, 
        {
            "location": "/#block_show", 
            "text": "Get contents of a block\n\nArgs:\n    'blockhash': (str) hash of the block to look up\nReturns:\n    (dict) Requested block", 
            "title": "block_show"
        }, 
        {
            "location": "/#channel_list_mine", 
            "text": "Get my channels\n\nReturns:\n    (list) ClaimDict", 
            "title": "channel_list_mine"
        }, 
        {
            "location": "/#channel_new", 
            "text": "Generate a publisher key and create a new certificate claim\n\nArgs:\n    'channel_name': (str) '@' prefixed name\n    'amount': (float) amount to claim name\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "channel_new"
        }, 
        {
            "location": "/#claim_abandon", 
            "text": "Abandon a name and reclaim credits from the claim\n\nArgs:\n    'claim_id': (str) claim_id of claim\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_abandon"
        }, 
        {
            "location": "/#claim_list", 
            "text": "Get claims for a name\n\nArgs:\n    'name': (str) search for claims on this name\nReturns\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }", 
            "title": "claim_list"
        }, 
        {
            "location": "/#claim_list_mine", 
            "text": "List my name claims\n\nArgs:\n    None\nReturns\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str)  claim ,  update  , or  support \n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'txid': (str) txid of the cliam\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]", 
            "title": "claim_list_mine"
        }, 
        {
            "location": "/#claim_new_support", 
            "text": "Support a name claim\n\nArgs:\n    'name': (str) Name of claim\n    'claim_id': (str) claim ID of claim to support\n    'amount': (float) amount to support by\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_new_support"
        }, 
        {
            "location": "/#claim_show", 
            "text": "Resolve claim info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\n    'txid'(optional): (str) if specified, look for claim with this txid\n    'nout'(optional): (int) if specified, look for claim with this nout\n    'claim_id'(optional): (str) if specified, look for claim with this claim_id\nReturns:\n    (dict) Dictionary containing claim info, (bool) false if claim is not\n        resolvable\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }", 
            "title": "claim_show"
        }, 
        {
            "location": "/#commands", 
            "text": "Return a list of available commands\n\nReturns:\n    (list) list of available commands", 
            "title": "commands"
        }, 
        {
            "location": "/#daemon_stop", 
            "text": "Stop lbrynet-daemon\n\nReturns:\n    (string) Shutdown message", 
            "title": "daemon_stop"
        }, 
        {
            "location": "/#descriptor_get", 
            "text": "Download and return a sd blob\n\nArgs:\n    'sd_hash': (str) hash of sd blob\n    'timeout'(optional): (int) timeout in number of seconds\n    'payment_rate_manager'(optional): (str) if not given the default payment rate manager\n                                     will be used. supported alternative rate managers:\n                                     only-free\n\nReturns\n    (str) Success/Fail message or (dict) decoded data", 
            "title": "descriptor_get"
        }, 
        {
            "location": "/#file_delete", 
            "text": "Delete a lbry file\n\nArgs:\n    'name' (optional): (str) delete file by lbry name,\n    'sd_hash' (optional): (str) delete file by sd hash,\n    'file_name' (optional): (str) delete file by the name in the downloads folder,\n    'stream_hash' (optional): (str) delete file by stream hash,\n    'claim_id' (optional): (str) delete file by claim ID,\n    'outpoint' (optional): (str) delete file by claim outpoint,\n    'rowid': (optional): (int) delete file by rowid in the file manager\n    'delete_target_file' (optional): (bool) delete file from downloads folder,\n                                    defaults to true if false only the blobs and\n                                    db entries will be deleted\nReturns:\n    (bool) true if deletion was successful", 
            "title": "file_delete"
        }, 
        {
            "location": "/#file_list", 
            "text": "List files limited by optional filters\n\nArgs:\n    'name' (optional): (str) filter files by lbry name,\n    'sd_hash' (optional): (str) filter files by sd hash,\n    'file_name' (optional): (str) filter files by the name in the downloads folder,\n    'stream_hash' (optional): (str) filter files by stream hash,\n    'claim_id' (optional): (str) filter files by claim id,\n    'outpoint' (optional): (str) filter files by claim outpoint,\n    'rowid' (optional): (int) filter files by internal row id,\n    'full_status': (optional): (bool) if true populate the 'message' and 'size' fields\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'name': (str) name claim attached to file\n            'outpoint': (str) claim outpoint attached to file\n            'claim_id': (str) claim ID attached to file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false\n            'written_bytes': (int) written size in bytes\n            'message': (str), None if full_status is false\n            'metadata': (dict) Metadata dictionary\n        },\n    ]", 
            "title": "file_list"
        }, 
        {
            "location": "/#file_set_status", 
            "text": "Start or stop downloading a file\n\nArgs:\n    'status': (str)  start  or  stop \n    'name' (optional): (str) start file by lbry name,\n    'sd_hash' (optional): (str) start file by the hash in the name claim,\n    'file_name' (optional): (str) start file by its name in the downloads folder,\nReturns:\n    (str) Confirmation message", 
            "title": "file_set_status"
        }, 
        {
            "location": "/#get", 
            "text": "Download stream from a LBRY name.\n\nArgs:\n    'uri': (str) lbry uri to download\n    'file_name'(optional): (str) a user specified name for the downloaded file\n    'timeout'(optional): (int) download timeout in number of seconds\n    'download_directory'(optional): (str) path to directory where file will be saved\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'name': (str) name claim attached to file\n        'outpoint': (str) claim outpoint attached to file\n        'claim_id': (str) claim ID attached to file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false\n        'written_bytes': (int) written size in bytes\n        'message': (str), None if full_status is false\n        'metadata': (dict) Metadata dictionary\n    }", 
            "title": "get"
        }, 
        {
            "location": "/#get_availability", 
            "text": "Get stream availability for lbry uri\n\nArgs:\n    'uri' : (str) lbry uri\n    'sd_timeout' (optional): (int) sd blob download timeout\n    'peer_timeout' (optional): (int) how long to look for peers\n\nReturns:\n    (float) Peers per blob / total blobs", 
            "title": "get_availability"
        }, 
        {
            "location": "/#help", 
            "text": "Return a useful message for an API command\n\nArgs:\n    'command'(optional): (str) command to retrieve documentation for\nReturns:\n    (str) if given a command, returns documentation about that command\n    otherwise returns general help message", 
            "title": "help"
        }, 
        {
            "location": "/#peer_list", 
            "text": "Get peers for blob hash\n\nArgs:\n    'blob_hash': (str) blob hash\n    'timeout'(optional): (int) peer search timeout in seconds\nReturns:\n    (list) List of contacts", 
            "title": "peer_list"
        }, 
        {
            "location": "/#publish", 
            "text": "Make a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license',\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nArgs:\n    'name': (str) name to be claimed\n    'bid': (float) amount of credits to commit in this claim,\n    'metadata'(optional): (dict) Metadata to associate with the claim.\n    'file_path'(optional): (str) path to file to be associated with name. If provided,\n                            a lbry stream of this file will be used in 'sources'.\n                            If no path is given but a metadata dict is provided, the source\n                            from the given metadata will be used.\n    'fee'(optional): (dict) Dictionary representing key fee to download content:\n                      {currency_symbol: {'amount': float, 'address': str, optional}}\n                      supported currencies: LBC, USD, BTC\n                      If an address is not provided a new one will be automatically\n                      generated. Default fee is zero.\n    'title'(optional): (str) title of the file\n    'description'(optional): (str) description of the file\n    'author'(optional): (str) author of the file\n    'language'(optional): (str), language code\n    'license'(optional): (str) license for the file\n    'license_url'(optional): (str) URL to license\n    'thumbnail'(optional): (str) thumbnail URL for the file\n    'preview'(optional): (str) preview URL for the file\n    'nsfw'(optional): (bool) True if not safe for work\n    'sources'(optional): (dict){'lbry_sd_hash':sd_hash} specifies sd hash of file\n    'channel_name' (optional): (str) name of the publisher channel\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "publish"
        }, 
        {
            "location": "/#reflect", 
            "text": "Reflect a stream\n\nArgs:\n    'sd_hash': (str) sd_hash of lbry file\nReturns:\n    (bool) true if successful", 
            "title": "reflect"
        }, 
        {
            "location": "/#report_bug", 
            "text": "Report a bug to slack\n\nArgs:\n    'message': (str) message to send\nReturns:\n    (bool) true if successful", 
            "title": "report_bug"
        }, 
        {
            "location": "/#resolve", 
            "text": "Resolve a LBRY URI\n\nArgs:\n    'uri': (str) uri to download\nReturns:\n    None if nothing can be resolved, otherwise:\n    If uri resolves to a channel or a claim in a channel:\n        'certificate': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}],\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    If uri resolves to a channel:\n        'claims_in_channel': [\n            {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'supports: (list) list of supports [{'txid': txid,\n                                                     'nout': nout,\n                                                     'amount': amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n        ]\n    If uri resolves to a claim:\n        'claim': {\n            'address': (str) claim address,\n            'amount': (float) claim amount,\n            'effective_amount': (float) claim amount including supports,\n            'claim_id': (str) claim id,\n            'claim_sequence': (int) claim sequence number,\n            'decoded_claim': (bool) whether or not the claim value was decoded,\n            'height': (int) claim height,\n            'depth': (int) claim depth,\n            'has_signature': (bool) included if decoded_claim\n            'name': (str) claim name,\n            'channel_name': (str) channel name if claim is in a channel\n            'supports: (list) list of supports [{'txid': txid,\n                                                 'nout': nout,\n                                                 'amount': amount}]\n            'txid': (str) claim txid,\n            'nout': (str) claim nout,\n            'signature_is_valid': (bool), included if has_signature,\n            'value': ClaimDict if decoded, otherwise hex string\n        }\n    }", 
            "title": "resolve"
        }, 
        {
            "location": "/#resolve_name", 
            "text": "Resolve stream info from a LBRY name\n\nArgs:\n    'name': (str) name to look up, do not include lbry:// prefix\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable", 
            "title": "resolve_name"
        }, 
        {
            "location": "/#send_amount_to_address", 
            "text": "Send credits to an address\n\nArgs:\n    'amount': (float) the amount to send\n    'address': (str) the address of the recipient in base58\nReturns:\n    (bool) true if payment successfully scheduled", 
            "title": "send_amount_to_address"
        }, 
        {
            "location": "/#settings_get", 
            "text": "Get daemon settings\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings", 
            "title": "settings_get"
        }, 
        {
            "location": "/#settings_set", 
            "text": "Set daemon settings\n\nArgs:\n    'run_on_startup': (bool) currently not supported\n    'data_rate': (float) data rate,\n    'max_key_fee': (float) maximum key fee,\n    'disable_max_key_fee': (bool) true to disable max_key_fee check,\n    'download_directory': (str) path of where files are downloaded,\n    'peer_port': (int) port through which daemon should connect,\n    'max_upload': (float), currently not supported\n    'max_download': (float), currently not supported\n    'download_timeout': (int) download timeout in seconds\n    'search_timeout': (float) search timeout in seconds\n    'cache_time': (int) cache timeout in seconds\nReturns:\n    (dict) Updated dictionary of daemon settings", 
            "title": "settings_set"
        }, 
        {
            "location": "/#status", 
            "text": "Return daemon status\n\nArgs:\n    'session_status' (optional): (bool) true to return session status,\n        default is false\nReturns:\n    (dict) Daemon status dictionary", 
            "title": "status"
        }, 
        {
            "location": "/#stream_cost_estimate", 
            "text": "Get estimated cost for a lbry stream\n\nArgs:\n    'name': (str) lbry name\n    'size' (optional): (int) stream size, in bytes. if provided an sd blob\n                        won't be downloaded.\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolveable", 
            "title": "stream_cost_estimate"
        }, 
        {
            "location": "/#transaction_list", 
            "text": "List transactions belonging to wallet\n\nArgs:\n    None\nReturns:\n    (list) List of transactions", 
            "title": "transaction_list"
        }, 
        {
            "location": "/#transaction_show", 
            "text": "Get a decoded transaction from a txid\n\nArgs:\n    'txid': (str) txid of transaction\nReturns:\n    (dict) JSON formatted transaction", 
            "title": "transaction_show"
        }, 
        {
            "location": "/#version", 
            "text": "Get lbry version information\n\nArgs:\n    None\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g.  dev ,  rc ,  release ),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }", 
            "title": "version"
        }, 
        {
            "location": "/#wallet_balance", 
            "text": "Return the balance of the wallet\n\nArgs:\n    'address' (optional): If address is provided only that balance will be given\n    'include_unconfirmed' (optional): If set unconfirmed balance will be included in\n     the only takes effect when address is also provided.\n\nReturns:\n    (float) amount of lbry credits in wallet", 
            "title": "wallet_balance"
        }, 
        {
            "location": "/#wallet_is_address_mine", 
            "text": "Checks if an address is associated with the current wallet.\n\nArgs:\n    'address': (str) address to check in base58\nReturns:\n    (bool) true, if address is associated with current wallet", 
            "title": "wallet_is_address_mine"
        }, 
        {
            "location": "/#wallet_list", 
            "text": "List wallet addresses\n\nArgs:\n    None\nReturns:\n    List of wallet addresses", 
            "title": "wallet_list"
        }, 
        {
            "location": "/#wallet_new_address", 
            "text": "Generate a new wallet address\n\nArgs:\n    None\nReturns:\n    (str) New wallet address in base58", 
            "title": "wallet_new_address"
        }, 
        {
            "location": "/#wallet_public_key", 
            "text": "Get public key from wallet address\n\nArgs:\n    'address': (str) wallet address in base58\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.", 
            "title": "wallet_public_key"
        }, 
        {
            "location": "/#wallet_unused_address", 
            "text": "Return an address containing no balance, will create\na new address if there is none.\n\nArgs:\n    None\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "wallet_unused_address"
        }, 
        {
            "location": "/cli/", 
            "text": "LBRY Command Line Documentation\n\n\nblob_announce\n\n\nAnnounce blobs to the DHT\n\nUsage:\n    blob_announce [-a] [\nblob_hash\n | --blob_hash=\nblob_hash\n]\n                  [\nstream_hash\n | --stream_hash=\nstream_hash\n]\n                  [\nsd_hash\n | --sd_hash=\nsd_hash\n]\n\nOptions:\n    -a                                          : announce all the blobs possessed by user\n    \nblob_hash\n, --blob_hash=\nblob_hash\n        : announce a blob, specified by blob_hash\n    \nstream_hash\n, --stream_hash=\nstream_hash\n  : announce all blobs associated with\n                                                    stream_hash\n    \nsd_hash\n, --sd_hash=\nsd_hash\n              : announce all blobs associated with\n                                                    sd_hash and the sd_hash itself\n\nReturns:\n    (bool) true if successful\n\n\n\n\nblob_delete\n\n\nDelete a blob\n\nUsage:\n    blob_delete (\nblob_hash\n | --blob_hash=\nblob_hash)\n\nReturns:\n    (str) Success/fail message\n\n\n\n\nblob_get\n\n\nDownload and return a blob\n\nUsage:\n    blob_get (\nblob_hash\n | --blob_hash=\nblob_hash\n) [--timeout=\ntimeout\n]\n             [--encoding=\nencoding\n] [--payment_rate_manager=\npayment_rate_manager\n]\n\nOptions:\n--timeout=\ntimeout\n                            : timeout in number of seconds\n--encoding=\nencoding\n                          : by default no attempt at decoding is made,\n                                                 can be set to one of the\n                                                 following decoders:\n                                                    'json'\n--payment_rate_manager=\npayment_rate_manager\n  : if not given the default payment rate\n                                                 manager will be used.\n                                                 supported alternative rate managers:\n                                                    'only-free'\n\nReturns\n    (str) Success/Fail message or (dict) decoded data\n\n\n\n\nblob_list\n\n\nReturns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nUsage:\n    blob_list [-n] [-f] [\nuri\n | --uri=\nuri\n] [\nstream_hash\n | --stream_hash=\nstream_hash\n]\n              [\nsd_hash\n | --sd_hash=\nsd_hash\n] [\npage_size\n | --page_size=\npage_size\n]\n              [\npage\n | --page=\npage\n]\n\nOptions:\n    -n                                          : only return needed blobs\n    -f                                          : only return finished blobs\n    \nuri\n, --uri=\nuri\n                          : filter blobs by stream in a uri\n    \nstream_hash\n, --stream_hash=\nstream_hash\n  : filter blobs by stream hash\n    \nsd_hash\n, --sd_hash=\nsd_hash\n              : filter blobs by sd hash\n    \npage_size\n, --page_size=\npage_size\n        : results page size\n    \npage\n, --page=\npage\n                       : page of results to return\n\nReturns:\n    (list) List of blob hashes\n\n\n\n\nblob_reflect_all\n\n\nReflects all saved blobs\n\nUsage:\n    blob_reflect_all\n\nReturns:\n    (bool) true if successful\n\n\n\n\nblock_show\n\n\nGet contents of a block\n\nUsage:\n    block_show (\nblockhash\n | --blockhash=\nblockhash\n) | (\nheight\n | --height=\nheight\n)\n\nOptions:\n    \nblockhash\n, --blockhash=\nblockhash\n  : hash of the block to look up\n    \nheight\n, --height=\nheight\n           : height of the block to look up\n\nReturns:\n    (dict) Requested block\n\n\n\n\nchannel_export\n\n\nExport serialized channel signing information for a given certificate claim id\n\nUsage:\n    channel_export (\nclaim_id\n | --claim_id=\nclaim_id\n)\n\nReturns:\n    (str) Serialized certificate information\n\n\n\n\nchannel_import\n\n\nImport serialized channel signing information (to allow signing new claims to the channel)\n\nUsage:\n    channel_import (\nserialized_certificate_info\n |\n                    --serialized_certificate_info=\nserialized_certificate_info\n)\n\nReturns:\n    (dict) Result dictionary\n\n\n\n\nchannel_list\n\n\nGet certificate claim infos for channels that can be published to\n\nUsage:\n    channel_list\n\nReturns:\n    (list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet.\n\n\n\n\nchannel_new\n\n\nGenerate a publisher key and create a new '@' prefixed certificate claim\n\nUsage:\n    channel_new (\nchannel_name\n | --channel_name=\nchannel_name\n)\n                (\namount\n | --amount=\namount\n)\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nclaim_abandon\n\n\nAbandon a name and reclaim credits from the claim\n\nUsage:\n    claim_abandon [\nclaim_id\n | --claim_id=\nclaim_id\n]\n                  [\ntxid\n | --txid=\ntxid\n] [\nnout\n | --nout=\nnout\n]\n\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_list\n\n\nList current claims and information about them for a given name\n\nUsage:\n    claim_list (\nname\n | --name=\nname\n)\n\nReturns\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }\n\n\n\n\nclaim_list_by_channel\n\n\nGet paginated claims in a channel specified by a channel uri\n\nUsage:\n    claim_list_by_channel (\nuri\n | --uri=\nuri\n) [\nuris\n...] [--page=\npage\n]\n                           [--page_size=\npage_size\n]\n\nOptions:\n    --page=\npage\n            : which page of results to return where page 1 is the first\n                               page, defaults to no pages\n    --page_size=\npage_size\n  : number of results in a page, default of 10\n\nReturns:\n    {\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }\n\n\n\n\nclaim_list_mine\n\n\nList my name claims\n\nUsage:\n    claim_list_mine\n\nReturns\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str) \nclaim\n, \nupdate\n , or \nsupport\n\n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'txid': (str) txid of the cliam\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]\n\n\n\n\nclaim_new_support\n\n\nSupport a name claim\n\nUsage:\n    claim_new_support (\nname\n | --name=\nname\n) (\nclaim_id\n | --claim_id=\nclaim_id\n)\n                      (\namount\n | --amount=\namount\n)\n\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nclaim_renew\n\n\nRenew claim(s) or support(s)\n\nUsage:\n    claim_renew (\noutpoint\n | --outpoint=\noutpoint\n) | (\nheight\n | --height=\nheight\n)\n\nReturn:\n    (dict) Dictionary where key is the the original claim's outpoint and\n    value is the result of the renewal\n    {\n        outpoint:{\n\n            'tx' : (str) hex encoded transaction\n            'txid' : (str) txid of resulting claim\n            'nout' : (int) nout of the resulting claim\n            'fee' : (float) fee paid for the claim transaction\n            'claim_id' : (str) claim ID of the resulting claim\n        },\n    }\n\n\n\n\nclaim_send_to_address\n\n\nSend a name claim to an address\n\nUsage:\n    claim_send_to_address (\nclaim_id\n | --claim_id=\nclaim_id\n)\n                          (\naddress\n | --address=\naddress\n)\n                          [\namount\n | --amount=\namount\n]\n\nOptions:\n    \namount\n  : Amount of credits to claim name for, defaults to the current amount\n                on the claim\n\n\n\n\nclaim_show\n\n\nResolve claim info from txid/nout or with claim ID\n\nUsage:\n    claim_show [\ntxid\n | --txid=\ntxid\n] [\nnout\n | --nout=\nnout\n]\n               [\nclaim_id\n | --claim_id=\nclaim_id\n]\n\nOptions:\n    \ntxid\n, --txid=\ntxid\n              : look for claim with this txid, nout must\n                                            also be specified\n    \nnout\n, --nout=\nnout\n              : look for claim with this nout, txid must\n                                            also be specified\n    \nclaim_id\n, --claim_id=\nclaim_id\n  : look for claim with this claim id\n\nReturns:\n    (dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }\n\n\n\n\ncli_test_command\n\n\nThis command is only for testing the CLI argument parsing\nUsage:\n    cli_test_command [-a] [-b] (\npos_arg\n | --pos_arg=\npos_arg\n)\n                     [\npos_args\n...] [--pos_arg2=\npos_arg2\n]\n                     [--pos_arg3=\npos_arg3\n]\n\nOptions:\n    -a, --a_arg                        : a arg\n    -b, --b_arg                        : b arg\n    \npos_arg2\n, --pos_arg2=\npos_arg2\n  : pos arg 2\n    \npos_arg3\n, --pos_arg3=\npos_arg3\n  : pos arg 3\nReturns:\n    pos args\n\n\n\n\ncommands\n\n\nReturn a list of available commands\n\nUsage:\n    commands\n\nReturns:\n    (list) list of available commands\n\n\n\n\ndaemon_stop\n\n\nStop lbrynet-daemon\n\nUsage:\n    daemon_stop\n\nReturns:\n    (string) Shutdown message\n\n\n\n\nfile_delete\n\n\nDelete a LBRY file\n\nUsage:\n    file_delete [-f] [--delete_all] [--sd_hash=\nsd_hash\n] [--file_name=\nfile_name\n]\n                [--stream_hash=\nstream_hash\n] [--rowid=\nrowid\n]\n\nOptions:\n    -f, --delete_from_download_dir  : delete file from download directory,\n                                        instead of just deleting blobs\n    --delete_all                    : if there are multiple matching files,\n                                        allow the deletion of multiple files.\n                                        Otherwise do not delete anything.\n    --sd_hash=\nsd_hash\n             : delete by file sd hash\n    --file_name\nfile_name\n          : delete by file name in downloads folder\n    --stream_hash=\nstream_hash\n     : delete by file stream hash\n    --rowid=\nrowid\n                 : delete by file row id\n\nReturns:\n    (bool) true if deletion was successful\n\n\n\n\nfile_list\n\n\nList files limited by optional filters\n\nUsage:\n    file_list [--sd_hash=\nsd_hash\n] [--file_name=\nfile_name\n] [--stream_hash=\nstream_hash\n]\n              [--rowid=\nrowid\n]\n              [-f]\n\nOptions:\n    --sd_hash=\nsd_hash\n          : get file with matching sd hash\n    --file_name=\nfile_name\n      : get file with matching file name in the\n                                   downloads folder\n    --stream_hash=\nstream_hash\n  : get file with matching stream hash\n    --rowid=\nrowid\n              : get file with matching row id\n    -f                           : full status, populate the 'message' and 'size' fields\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false\n            'written_bytes': (int) written size in bytes\n            'message': (str), None if full_status is false\n        },\n    ]\n\n\n\n\nfile_reflect\n\n\nReflect all the blobs in a file matching the filter criteria\n\nUsage:\n    file_reflect [--sd_hash=\nsd_hash\n] [--file_name=\nfile_name\n]\n                 [--stream_hash=\nstream_hash\n] [--rowid=\nrowid\n]\n                 [--reflector=\nreflector\n]\n\nOptions:\n    --sd_hash=\nsd_hash\n          : get file with matching sd hash\n    --file_name=\nfile_name\n      : get file with matching file name in the\n                                   downloads folder\n    --stream_hash=\nstream_hash\n  : get file with matching stream hash\n    --rowid=\nrowid\n              : get file with matching row id\n    --reflector=\nreflector\n      : reflector server, ip address or url\n                                   by default choose a server from the config\n\nReturns:\n    (list) list of blobs reflected\n\n\n\n\nfile_set_status\n\n\nStart or stop downloading a file\n\nUsage:\n    file_set_status \nstatus\n [--sd_hash=\nsd_hash\n] [--file_name=\nfile_name\n]\n              [--stream_hash=\nstream_hash\n] [--rowid=\nrowid\n]\n\nOptions:\n    --sd_hash=\nsd_hash\n          : set status of file with matching sd hash\n    --file_name=\nfile_name\n      : set status of file with matching file name in the\n                                   downloads folder\n    --stream_hash=\nstream_hash\n  : set status of file with matching stream hash\n    --rowid=\nrowid\n              : set status of file with matching row id\n\nReturns:\n    (str) Confirmation message\n\n\n\n\nget\n\n\nDownload stream from a LBRY name.\n\nUsage:\n    get \nuri\n [\nfile_name\n | --file_name=\nfile_name\n] [\ntimeout\n | --timeout=\ntimeout\n]\n\n\nOptions:\n    \nfile_name\n           : specified name for the downloaded file\n    \ntimeout\n             : download timeout in number of seconds\n    \ndownload_directory\n  : path to directory where file will be saved\n\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'name': (str) name claim attached to file\n        'outpoint': (str) claim outpoint attached to file\n        'claim_id': (str) claim ID attached to file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false\n        'written_bytes': (int) written size in bytes\n        'message': (str), None if full_status is false\n        'metadata': (dict) Metadata dictionary\n    }\n\n\n\n\nget_availability\n\n\nGet stream availability for lbry uri\n\nUsage:\n    get_availability (\nuri\n | --uri=\nuri\n) [\nsd_timeout\n | --sd_timeout=\nsd_timeout\n]\n                     [\npeer_timeout\n | --peer_timeout=\npeer_timeout\n]\n\nOptions:\n    \nsd_timeout\n, --sd_timeout=\nsd_timeout\n        : sd blob download timeout\n    \npeer_timeout\n, --peer_timeout=\npeer_timeout\n  : how long to look for peers\n\nReturns:\n    (float) Peers per blob / total blobs\n\n\n\n\nhelp\n\n\nReturn a useful message for an API command\n\nUsage:\n    help [\ncommand\n | --command=\ncommand\n]\n\nOptions:\n    \ncommand\n, --command=\ncommand\n  : command to retrieve documentation for\n\n\n\n\npeer_list\n\n\nGet peers for blob hash\n\nUsage:\n    peer_list (\nblob_hash\n | --blob_hash=\nblob_hash\n) [\ntimeout\n | --timeout=\ntimeout\n]\n\nOptions:\n    \ntimeout\n, --timeout=\ntimeout\n  : peer search timeout in seconds\n\nReturns:\n    (list) List of contacts\n\n\n\n\npublish\n\n\nMake a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license'\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nUsage:\n    publish (\nname\n | --name=\nname\n) (\nbid\n | --bid=\nbid\n) [--metadata=\nmetadata\n]\n            [--file_path=\nfile_path\n] [--fee=\nfee\n] [--title=\ntitle\n]\n            [--description=\ndescription\n] [--author=\nauthor\n] [--language=\nlanguage\n]\n            [--license=\nlicense\n] [--license_url=\nlicense_url\n] [--thumbnail=\nthumbnail\n]\n            [--preview=\npreview\n] [--nsfw=\nnsfw\n] [--sources=\nsources\n]\n            [--channel_name=\nchannel_name\n] [--channel_id=\nchannel_id\n]\n            [--claim_address=\nclaim_address\n] [--change_address=\nchange_address\n]\n\nOptions:\n    --metadata=\nmetadata\n          : ClaimDict to associate with the claim.\n    --file_path=\nfile_path\n        : path to file to be associated with name. If provided,\n                                     a lbry stream of this file will be used in 'sources'.\n                                     If no path is given but a sources dict is provided,\n                                     it will be used. If neither are provided, an\n                                     error is raised.\n    --fee=\nfee\n                    : Dictionary representing key fee to download content:\n                                      {\n                                        'currency': currency_symbol,\n                                        'amount': float,\n                                        'address': str, optional\n                                      }\n                                      supported currencies: LBC, USD, BTC\n                                      If an address is not provided a new one will be\n                                      automatically generated. Default fee is zero.\n    --title=\ntitle\n                : title of the publication\n    --description=\ndescription\n    : description of the publication\n    --author=\nauthor\n              : author of the publication\n    --language=\nlanguage\n          : language of the publication\n    --license=\nlicense\n            : publication license\n    --license_url=\nlicense_url\n    : publication license url\n    --thumbnail=\nthumbnail\n        : thumbnail url\n    --preview=\npreview\n            : preview url\n    --nsfw=\nnsfw\n                  : title of the publication\n    --sources=\nsources\n            : {'lbry_sd_hash':sd_hash} specifies sd hash of file\n    --channel_name=\nchannel_name\n  : name of the publisher channel name in the wallet\n    --channel_id=\nchannel_id\n      : claim id of the publisher channel, does not check\n                                     for channel claim being in the wallet. This allows\n                                     publishing to a channel where only the certificate\n                                     private key is in the wallet.\n   --claim_address=\nclaim_address\n : address where the claim is sent to, if not specified\n                                     new address wil automatically be created\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }\n\n\n\n\nreport_bug\n\n\nReport a bug to slack\n\nUsage:\n    report_bug (\nmessage\n | --message=\nmessage\n)\n\nReturns:\n    (bool) true if successful\n\n\n\n\nresolve\n\n\nResolve given LBRY URIs\n\nUsage:\n    resolve [-f] (\nuri\n | --uri=\nuri\n) [\nuris\n...]\n\nOptions:\n    -f  : force refresh and ignore cache\n\nReturns:\n    Dictionary of results, keyed by uri\n    '\nuri\n': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }\n\n\n\n\nresolve_name\n\n\nResolve stream info from a LBRY name\n\nUsage:\n    resolve_name \nname\n [-f]\n\nOptions:\n    -f  : force refresh and do not check cache\n\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable\n\n\n\n\nrouting_table_get\n\n\nGet DHT routing information\n\nUsage:\n    routing_table_get\n\nReturns:\n    (dict) dictionary containing routing and contact information\n    {\n        \nbuckets\n: {\n            \nbucket index\n: [\n                {\n                    \naddress\n: (str) peer address,\n                    \nnode_id\n: (str) peer node id,\n                    \nblobs\n: (list) blob hashes announced by peer\n                }\n            ]\n        },\n        \ncontacts\n: (list) contact node ids,\n        \nblob_hashes\n: (list) all of the blob hashes stored by peers in the list of buckets,\n        \nnode_id\n: (str) the local dht node id\n    }\n\n\n\n\nsettings_get\n\n\nGet daemon settings\n\nUsage:\n    settings_get\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings\n\n\n\n\nsettings_set\n\n\nSet daemon settings\n\nUsage:\n    settings_set [\ndownload_directory\n | --download_directory=\ndownload_directory\n]\n                 [\ndata_rate\n | --data_rate=\ndata_rate\n]\n                 [\ndownload_timeout\n | --download_timeout=\ndownload_timeout\n]\n                 [\npeer_port\n | --peer_port=\npeer_port\n]\n                 [\nmax_key_fee\n | --max_key_fee=\nmax_key_fee\n]\n                 [\ndisable_max_key_fee\n | --disable_max_key_fee=\ndisable_max_key_fee\n]\n                 [\nuse_upnp\n | --use_upnp=\nuse_upnp\n]\n                 [\nrun_reflector_server\n | --run_reflector_server=\nrun_reflector_server\n]\n                 [\ncache_time\n | --cache_time=\ncache_time\n]\n                 [\nreflect_uploads\n | --reflect_uploads=\nreflect_uploads\n]\n                 [\nshare_usage_data\n | --share_usage_data=\nshare_usage_data\n]\n                 [\npeer_search_timeout\n | --peer_search_timeout=\npeer_search_timeout\n]\n                 [\nsd_download_timeout\n | --sd_download_timeout=\nsd_download_timeout\n]\n                 [\nauto_renew_claim_height_delta\n\n                    | --auto_renew_claim_height_delta=\nauto_renew_claim_height_delta]\n\nOptions:\n    \ndownload_directory\n, --download_directory=\ndownload_directory\n  : (str)\n    \ndata_rate\n, --data_rate=\ndata_rate\n                             : (float), 0.0001\n    \ndownload_timeout\n, --download_timeout=\ndownload_timeout\n        : (int), 180\n    \npeer_port\n, --peer_port=\npeer_port\n                             : (int), 3333\n    \nmax_key_fee\n, --max_key_fee=\nmax_key_fee\n   : (dict) maximum key fee for downloads,\n                                                    in the format: {\n                                                        \ncurrency\n: \ncurrency_symbol\n,\n                                                        \namount\n: \namount\n\n                                                    }. In the CLI, it must be an escaped\n                                                    JSON string\n                                                    Supported currency symbols:\n                                                        LBC\n                                                        BTC\n                                                        USD\n    \ndisable_max_key_fee\n, --disable_max_key_fee=\ndisable_max_key_fee\n : (bool), False\n    \nuse_upnp\n, --use_upnp=\nuse_upnp\n            : (bool), True\n    \nrun_reflector_server\n, --run_reflector_server=\nrun_reflector_server\n  : (bool), False\n    \ncache_time\n, --cache_time=\ncache_time\n  : (int), 150\n    \nreflect_uploads\n, --reflect_uploads=\nreflect_uploads\n  : (bool), True\n    \nshare_usage_data\n, --share_usage_data=\nshare_usage_data\n  : (bool), True\n    \npeer_search_timeout\n, --peer_search_timeout=\npeer_search_timeout\n  : (int), 3\n    \nsd_download_timeout\n, --sd_download_timeout=\nsd_download_timeout\n  : (int), 3\n    \nauto_renew_claim_height_delta\n,\n        --auto_renew_claim_height_delta=\nauto_renew_claim_height_delta\n : (int), 0\n        claims set to expire within this many blocks will be\n        automatically renewed after startup (if set to 0, renews\n        will not be made automatically)\n\n\nReturns:\n    (dict) Updated dictionary of daemon settings\n\n\n\n\nstatus\n\n\nGet daemon status\n\nUsage:\n    status [-s] [-d]\n\nOptions:\n    -s  : include session status in results\n    -d  : include dht network and peer status\n\nReturns:\n    (dict) lbrynet-daemon status\n    {\n        'lbry_id': lbry peer id, base58\n        'installation_id': installation id, base58\n        'is_running': bool\n        'is_first_run': bool\n        'startup_status': {\n            'code': status code\n            'message': status message\n        },\n        'connection_status': {\n            'code': connection status code\n            'message': connection status message\n        },\n        'blockchain_status': {\n            'blocks': local blockchain height,\n            'blocks_behind': remote_height - local_height,\n            'best_blockhash': block hash of most recent block,\n        },\n\n        If given the session status option:\n            'session_status': {\n                'managed_blobs': count of blobs in the blob manager,\n                'managed_streams': count of streams in the file manager\n                'announce_queue_size': number of blobs currently queued to be announced\n                'should_announce_blobs': number of blobs that should be announced\n            }\n\n        If given the dht status option:\n            'dht_status': {\n                'kbps_received': current kbps receiving,\n                'kbps_sent': current kdps being sent,\n                'total_bytes_sent': total bytes sent\n                'total_bytes_received': total bytes received\n                'queries_received': number of queries received per second\n                'queries_sent': number of queries sent per second\n                'recent_contacts': count of recently contacted peers\n                'unique_contacts': count of unique peers\n            }\n    }\n\n\n\n\nstream_cost_estimate\n\n\nGet estimated cost for a lbry stream\n\nUsage:\n    stream_cost_estimate \nuri\n [\nsize\n | --size=\nsize\n]\n\nOptions:\n    \nsize\n, --size=\nsize\n  : stream size in bytes. if provided an sd blob won't be\n                             downloaded.\n\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolveable\n\n\n\n\ntransaction_list\n\n\nList transactions belonging to wallet\n\nUsage:\n    transaction_list [-t]\n\nOptions:\n    -t  : Include claim tip information\n\nReturns:\n    (list) List of transactions, where is_tip is null by default,\n     and set to a boolean if include_tip_info is true\n\n    {\n        \nclaim_info\n: (list) claim info if in txn [{\namount\n: (float) claim amount,\n                                                    \nclaim_id\n: (str) claim id,\n                                                    \nclaim_name\n: (str) claim name,\n                                                    \nnout\n: (int) nout}],\n        \nconfirmations\n: (int) number of confirmations for the txn,\n        \ndate\n: (str) date and time of txn,\n        \nfee\n: (float) txn fee,\n        \nsupport_info\n: (list) support info if in txn [{\namount\n: (float) support amount,\n                                                        \nclaim_id\n: (str) claim id,\n                                                        \nclaim_name\n: (str) claim name,\n                                                        \nis_tip\n: (null) default,\n                                                        (bool) if include_tip_info is true,\n                                                        \nnout\n: (int) nout}],\n        \ntimestamp\n: (int) timestamp,\n        \ntxid\n: (str) txn id,\n        \nupdate_info\n: (list) update info if in txn [{\namount\n: (float) updated amount,\n                                                      \nclaim_id\n: (str) claim id,\n                                                      \nclaim_name\n: (str) claim name,\n                                                      \nnout\n: (int) nout}],\n        \nvalue\n: (float) value of txn\n    }\n\n\n\n\ntransaction_show\n\n\nGet a decoded transaction from a txid\n\nUsage:\n    transaction_show (\ntxid\n | --txid=\ntxid\n)\n\nReturns:\n    (dict) JSON formatted transaction\n\n\n\n\nutxo_list\n\n\nList unspent transaction outputs\n\nUsage:\n    utxo_list\n\nReturns:\n    (list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n            \naddress\n: (str) the output address\n            \namount\n: (float) unspent amount\n            \nheight\n: (int) block height\n            \nis_claim\n: (bool) is the tx a claim\n            \nis_coinbase\n: (bool) is the tx a coinbase tx\n            \nis_support\n: (bool) is the tx a support\n            \nis_update\n: (bool) is the tx an update\n            \nnout\n: (int) nout of the output\n            \ntxid\n: (str) txid of the output\n        },\n        ...\n    ]\n\n\n\n\nversion\n\n\nGet lbry version information\n\nUsage:\n    version\n\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g. \ndev\n, \nrc\n, \nrelease\n),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }\n\n\n\n\nwallet_balance\n\n\nReturn the balance of the wallet\n\nUsage:\n    wallet_balance [\naddress\n | --address=\naddress\n] [-u]\n\nOptions:\n    \naddress\n  :  If provided only the balance for this address will be given\n    -u         :  Include unconfirmed\n\nReturns:\n    (float) amount of lbry credits in wallet\n\n\n\n\nwallet_is_address_mine\n\n\nChecks if an address is associated with the current wallet.\n\nUsage:\n    wallet_is_address_mine (\naddress\n | --address=\naddress\n)\n\nReturns:\n    (bool) true, if address is associated with current wallet\n\n\n\n\nwallet_list\n\n\nList wallet addresses\n\nUsage:\n    wallet_list\n\nReturns:\n    List of wallet addresses\n\n\n\n\nwallet_new_address\n\n\nGenerate a new wallet address\n\nUsage:\n    wallet_new_address\n\nReturns:\n    (str) New wallet address in base58\n\n\n\n\nwallet_prefill_addresses\n\n\nCreate new addresses, each containing `amount` credits\n\nUsage:\n    wallet_prefill_addresses [--no_broadcast]\n                             (\nnum_addresses\n | --num_addresses=\nnum_addresses\n)\n                             (\namount\n | --amount=\namount\n)\n\nReturns:\n    (dict) the resulting transaction\n\n\n\n\nwallet_public_key\n\n\nGet public key from wallet address\n\nUsage:\n    wallet_public_key (\naddress\n | --address=\naddress\n)\n\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.\n\n\n\n\nwallet_send\n\n\nSend credits. If given an address, send credits to it. If given a claim id, send a tip\nto the owner of a claim specified by uri. A tip is a claim support where the recipient\nof the support is the claim address for the claim being supported.\n\nUsage:\n    wallet_send (\namount\n | --amount=\namount\n)\n                ((\naddress\n | --address=\naddress\n) | (\nclaim_id\n | --claim_id=\nclaim_id\n))\n\nReturn:\n    If sending to an address:\n    (bool) true if payment successfully scheduled\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }\n\n\n\n\nwallet_unused_address\n\n\nReturn an address containing no balance, will create\na new address if there is none.\n\nUsage:\n    wallet_unused_address\n\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "CLI"
        }, 
        {
            "location": "/cli/#lbry-command-line-documentation", 
            "text": "", 
            "title": "LBRY Command Line Documentation"
        }, 
        {
            "location": "/cli/#blob_announce", 
            "text": "Announce blobs to the DHT\n\nUsage:\n    blob_announce [-a] [ blob_hash  | --blob_hash= blob_hash ]\n                  [ stream_hash  | --stream_hash= stream_hash ]\n                  [ sd_hash  | --sd_hash= sd_hash ]\n\nOptions:\n    -a                                          : announce all the blobs possessed by user\n     blob_hash , --blob_hash= blob_hash         : announce a blob, specified by blob_hash\n     stream_hash , --stream_hash= stream_hash   : announce all blobs associated with\n                                                    stream_hash\n     sd_hash , --sd_hash= sd_hash               : announce all blobs associated with\n                                                    sd_hash and the sd_hash itself\n\nReturns:\n    (bool) true if successful", 
            "title": "blob_announce"
        }, 
        {
            "location": "/cli/#blob_delete", 
            "text": "Delete a blob\n\nUsage:\n    blob_delete ( blob_hash  | --blob_hash= blob_hash)\n\nReturns:\n    (str) Success/fail message", 
            "title": "blob_delete"
        }, 
        {
            "location": "/cli/#blob_get", 
            "text": "Download and return a blob\n\nUsage:\n    blob_get ( blob_hash  | --blob_hash= blob_hash ) [--timeout= timeout ]\n             [--encoding= encoding ] [--payment_rate_manager= payment_rate_manager ]\n\nOptions:\n--timeout= timeout                             : timeout in number of seconds\n--encoding= encoding                           : by default no attempt at decoding is made,\n                                                 can be set to one of the\n                                                 following decoders:\n                                                    'json'\n--payment_rate_manager= payment_rate_manager   : if not given the default payment rate\n                                                 manager will be used.\n                                                 supported alternative rate managers:\n                                                    'only-free'\n\nReturns\n    (str) Success/Fail message or (dict) decoded data", 
            "title": "blob_get"
        }, 
        {
            "location": "/cli/#blob_list", 
            "text": "Returns blob hashes. If not given filters, returns all blobs known by the blob manager\n\nUsage:\n    blob_list [-n] [-f] [ uri  | --uri= uri ] [ stream_hash  | --stream_hash= stream_hash ]\n              [ sd_hash  | --sd_hash= sd_hash ] [ page_size  | --page_size= page_size ]\n              [ page  | --page= page ]\n\nOptions:\n    -n                                          : only return needed blobs\n    -f                                          : only return finished blobs\n     uri , --uri= uri                           : filter blobs by stream in a uri\n     stream_hash , --stream_hash= stream_hash   : filter blobs by stream hash\n     sd_hash , --sd_hash= sd_hash               : filter blobs by sd hash\n     page_size , --page_size= page_size         : results page size\n     page , --page= page                        : page of results to return\n\nReturns:\n    (list) List of blob hashes", 
            "title": "blob_list"
        }, 
        {
            "location": "/cli/#blob_reflect_all", 
            "text": "Reflects all saved blobs\n\nUsage:\n    blob_reflect_all\n\nReturns:\n    (bool) true if successful", 
            "title": "blob_reflect_all"
        }, 
        {
            "location": "/cli/#block_show", 
            "text": "Get contents of a block\n\nUsage:\n    block_show ( blockhash  | --blockhash= blockhash ) | ( height  | --height= height )\n\nOptions:\n     blockhash , --blockhash= blockhash   : hash of the block to look up\n     height , --height= height            : height of the block to look up\n\nReturns:\n    (dict) Requested block", 
            "title": "block_show"
        }, 
        {
            "location": "/cli/#channel_export", 
            "text": "Export serialized channel signing information for a given certificate claim id\n\nUsage:\n    channel_export ( claim_id  | --claim_id= claim_id )\n\nReturns:\n    (str) Serialized certificate information", 
            "title": "channel_export"
        }, 
        {
            "location": "/cli/#channel_import", 
            "text": "Import serialized channel signing information (to allow signing new claims to the channel)\n\nUsage:\n    channel_import ( serialized_certificate_info  |\n                    --serialized_certificate_info= serialized_certificate_info )\n\nReturns:\n    (dict) Result dictionary", 
            "title": "channel_import"
        }, 
        {
            "location": "/cli/#channel_list", 
            "text": "Get certificate claim infos for channels that can be published to\n\nUsage:\n    channel_list\n\nReturns:\n    (list) ClaimDict, includes 'is_mine' field to indicate if the certificate claim\n    is in the wallet.", 
            "title": "channel_list"
        }, 
        {
            "location": "/cli/#channel_new", 
            "text": "Generate a publisher key and create a new '@' prefixed certificate claim\n\nUsage:\n    channel_new ( channel_name  | --channel_name= channel_name )\n                ( amount  | --amount= amount )\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "channel_new"
        }, 
        {
            "location": "/cli/#claim_abandon", 
            "text": "Abandon a name and reclaim credits from the claim\n\nUsage:\n    claim_abandon [ claim_id  | --claim_id= claim_id ]\n                  [ txid  | --txid= txid ] [ nout  | --nout= nout ]\n\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting transaction\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_abandon"
        }, 
        {
            "location": "/cli/#claim_list", 
            "text": "List current claims and information about them for a given name\n\nUsage:\n    claim_list ( name  | --name= name )\n\nReturns\n    (dict) State of claims assigned for the name\n    {\n        'claims': (list) list of claims for the name\n        [\n            {\n            'amount': (float) amount assigned to the claim\n            'effective_amount': (float) total amount assigned to the claim,\n                                including supports\n            'claim_id': (str) claim ID of the claim\n            'height': (int) height of block containing the claim\n            'txid': (str) txid of the claim\n            'nout': (int) nout of the claim\n            'supports': (list) a list of supports attached to the claim\n            'value': (str) the value of the claim\n            },\n        ]\n        'supports_without_claims': (list) supports without any claims attached to them\n        'last_takeover_height': (int) the height of last takeover for the name\n    }", 
            "title": "claim_list"
        }, 
        {
            "location": "/cli/#claim_list_by_channel", 
            "text": "Get paginated claims in a channel specified by a channel uri\n\nUsage:\n    claim_list_by_channel ( uri  | --uri= uri ) [ uris ...] [--page= page ]\n                           [--page_size= page_size ]\n\nOptions:\n    --page= page             : which page of results to return where page 1 is the first\n                               page, defaults to no pages\n    --page_size= page_size   : number of results in a page, default of 10\n\nReturns:\n    {\n         resolved channel uri: {\n            If there was an error:\n            'error': (str) error message\n\n            'claims_in_channel': the total number of results for the channel,\n\n            If a page of results was requested:\n            'returned_page': page number returned,\n            'claims_in_channel': [\n                {\n                    'absolute_channel_position': (int) claim index number in sorted list of\n                                                 claims which assert to be part of the\n                                                 channel\n                    'address': (str) claim address,\n                    'amount': (float) claim amount,\n                    'effective_amount': (float) claim amount including supports,\n                    'claim_id': (str) claim id,\n                    'claim_sequence': (int) claim sequence number,\n                    'decoded_claim': (bool) whether or not the claim value was decoded,\n                    'height': (int) claim height,\n                    'depth': (int) claim depth,\n                    'has_signature': (bool) included if decoded_claim\n                    'name': (str) claim name,\n                    'supports: (list) list of supports [{'txid': (str) txid,\n                                                         'nout': (int) nout,\n                                                         'amount': (float) amount}],\n                    'txid': (str) claim txid,\n                    'nout': (str) claim nout,\n                    'signature_is_valid': (bool), included if has_signature,\n                    'value': ClaimDict if decoded, otherwise hex string\n                }\n            ],\n        }\n    }", 
            "title": "claim_list_by_channel"
        }, 
        {
            "location": "/cli/#claim_list_mine", 
            "text": "List my name claims\n\nUsage:\n    claim_list_mine\n\nReturns\n    (list) List of name claims owned by user\n    [\n        {\n            'address': (str) address that owns the claim\n            'amount': (float) amount assigned to the claim\n            'blocks_to_expiration': (int) number of blocks until it expires\n            'category': (str)  claim ,  update  , or  support \n            'claim_id': (str) claim ID of the claim\n            'confirmations': (int) number of blocks of confirmations for the claim\n            'expiration_height': (int) the block height which the claim will expire\n            'expired': (bool) true if expired, false otherwise\n            'height': (int) height of the block containing the claim\n            'is_spent': (bool) true if claim is abandoned, false otherwise\n            'name': (str) name of the claim\n            'txid': (str) txid of the cliam\n            'nout': (int) nout of the claim\n            'value': (str) value of the claim\n        },\n   ]", 
            "title": "claim_list_mine"
        }, 
        {
            "location": "/cli/#claim_new_support", 
            "text": "Support a name claim\n\nUsage:\n    claim_new_support ( name  | --name= name ) ( claim_id  | --claim_id= claim_id )\n                      ( amount  | --amount= amount )\n\nReturn:\n    (dict) Dictionary containing result of the claim\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "claim_new_support"
        }, 
        {
            "location": "/cli/#claim_renew", 
            "text": "Renew claim(s) or support(s)\n\nUsage:\n    claim_renew ( outpoint  | --outpoint= outpoint ) | ( height  | --height= height )\n\nReturn:\n    (dict) Dictionary where key is the the original claim's outpoint and\n    value is the result of the renewal\n    {\n        outpoint:{\n\n            'tx' : (str) hex encoded transaction\n            'txid' : (str) txid of resulting claim\n            'nout' : (int) nout of the resulting claim\n            'fee' : (float) fee paid for the claim transaction\n            'claim_id' : (str) claim ID of the resulting claim\n        },\n    }", 
            "title": "claim_renew"
        }, 
        {
            "location": "/cli/#claim_send_to_address", 
            "text": "Send a name claim to an address\n\nUsage:\n    claim_send_to_address ( claim_id  | --claim_id= claim_id )\n                          ( address  | --address= address )\n                          [ amount  | --amount= amount ]\n\nOptions:\n     amount   : Amount of credits to claim name for, defaults to the current amount\n                on the claim", 
            "title": "claim_send_to_address"
        }, 
        {
            "location": "/cli/#claim_show", 
            "text": "Resolve claim info from txid/nout or with claim ID\n\nUsage:\n    claim_show [ txid  | --txid= txid ] [ nout  | --nout= nout ]\n               [ claim_id  | --claim_id= claim_id ]\n\nOptions:\n     txid , --txid= txid               : look for claim with this txid, nout must\n                                            also be specified\n     nout , --nout= nout               : look for claim with this nout, txid must\n                                            also be specified\n     claim_id , --claim_id= claim_id   : look for claim with this claim id\n\nReturns:\n    (dict) Dictionary containing claim info as below,\n\n    {\n        'txid': (str) txid of claim\n        'nout': (int) nout of claim\n        'amount': (float) amount of claim\n        'value': (str) value of claim\n        'height' : (int) height of claim takeover\n        'claim_id': (str) claim ID of claim\n        'supports': (list) list of supports associated with claim\n    }\n\n    if claim cannot be resolved, dictionary as below will be returned\n\n    {\n        'error': (str) reason for error\n    }", 
            "title": "claim_show"
        }, 
        {
            "location": "/cli/#cli_test_command", 
            "text": "This command is only for testing the CLI argument parsing\nUsage:\n    cli_test_command [-a] [-b] ( pos_arg  | --pos_arg= pos_arg )\n                     [ pos_args ...] [--pos_arg2= pos_arg2 ]\n                     [--pos_arg3= pos_arg3 ]\n\nOptions:\n    -a, --a_arg                        : a arg\n    -b, --b_arg                        : b arg\n     pos_arg2 , --pos_arg2= pos_arg2   : pos arg 2\n     pos_arg3 , --pos_arg3= pos_arg3   : pos arg 3\nReturns:\n    pos args", 
            "title": "cli_test_command"
        }, 
        {
            "location": "/cli/#commands", 
            "text": "Return a list of available commands\n\nUsage:\n    commands\n\nReturns:\n    (list) list of available commands", 
            "title": "commands"
        }, 
        {
            "location": "/cli/#daemon_stop", 
            "text": "Stop lbrynet-daemon\n\nUsage:\n    daemon_stop\n\nReturns:\n    (string) Shutdown message", 
            "title": "daemon_stop"
        }, 
        {
            "location": "/cli/#file_delete", 
            "text": "Delete a LBRY file\n\nUsage:\n    file_delete [-f] [--delete_all] [--sd_hash= sd_hash ] [--file_name= file_name ]\n                [--stream_hash= stream_hash ] [--rowid= rowid ]\n\nOptions:\n    -f, --delete_from_download_dir  : delete file from download directory,\n                                        instead of just deleting blobs\n    --delete_all                    : if there are multiple matching files,\n                                        allow the deletion of multiple files.\n                                        Otherwise do not delete anything.\n    --sd_hash= sd_hash              : delete by file sd hash\n    --file_name file_name           : delete by file name in downloads folder\n    --stream_hash= stream_hash      : delete by file stream hash\n    --rowid= rowid                  : delete by file row id\n\nReturns:\n    (bool) true if deletion was successful", 
            "title": "file_delete"
        }, 
        {
            "location": "/cli/#file_list", 
            "text": "List files limited by optional filters\n\nUsage:\n    file_list [--sd_hash= sd_hash ] [--file_name= file_name ] [--stream_hash= stream_hash ]\n              [--rowid= rowid ]\n              [-f]\n\nOptions:\n    --sd_hash= sd_hash           : get file with matching sd hash\n    --file_name= file_name       : get file with matching file name in the\n                                   downloads folder\n    --stream_hash= stream_hash   : get file with matching stream hash\n    --rowid= rowid               : get file with matching row id\n    -f                           : full status, populate the 'message' and 'size' fields\n\nReturns:\n    (list) List of files\n\n    [\n        {\n            'completed': (bool) true if download is completed,\n            'file_name': (str) name of file,\n            'download_directory': (str) download directory,\n            'points_paid': (float) credit paid to download file,\n            'stopped': (bool) true if download is stopped,\n            'stream_hash': (str) stream hash of file,\n            'stream_name': (str) stream name ,\n            'suggested_file_name': (str) suggested file name,\n            'sd_hash': (str) sd hash of file,\n            'download_path': (str) download path of file,\n            'mime_type': (str) mime type of file,\n            'key': (str) key attached to file,\n            'total_bytes': (int) file size in bytes, None if full_status is false\n            'written_bytes': (int) written size in bytes\n            'message': (str), None if full_status is false\n        },\n    ]", 
            "title": "file_list"
        }, 
        {
            "location": "/cli/#file_reflect", 
            "text": "Reflect all the blobs in a file matching the filter criteria\n\nUsage:\n    file_reflect [--sd_hash= sd_hash ] [--file_name= file_name ]\n                 [--stream_hash= stream_hash ] [--rowid= rowid ]\n                 [--reflector= reflector ]\n\nOptions:\n    --sd_hash= sd_hash           : get file with matching sd hash\n    --file_name= file_name       : get file with matching file name in the\n                                   downloads folder\n    --stream_hash= stream_hash   : get file with matching stream hash\n    --rowid= rowid               : get file with matching row id\n    --reflector= reflector       : reflector server, ip address or url\n                                   by default choose a server from the config\n\nReturns:\n    (list) list of blobs reflected", 
            "title": "file_reflect"
        }, 
        {
            "location": "/cli/#file_set_status", 
            "text": "Start or stop downloading a file\n\nUsage:\n    file_set_status  status  [--sd_hash= sd_hash ] [--file_name= file_name ]\n              [--stream_hash= stream_hash ] [--rowid= rowid ]\n\nOptions:\n    --sd_hash= sd_hash           : set status of file with matching sd hash\n    --file_name= file_name       : set status of file with matching file name in the\n                                   downloads folder\n    --stream_hash= stream_hash   : set status of file with matching stream hash\n    --rowid= rowid               : set status of file with matching row id\n\nReturns:\n    (str) Confirmation message", 
            "title": "file_set_status"
        }, 
        {
            "location": "/cli/#get", 
            "text": "Download stream from a LBRY name.\n\nUsage:\n    get  uri  [ file_name  | --file_name= file_name ] [ timeout  | --timeout= timeout ]\n\n\nOptions:\n     file_name            : specified name for the downloaded file\n     timeout              : download timeout in number of seconds\n     download_directory   : path to directory where file will be saved\n\nReturns:\n    (dict) Dictionary containing information about the stream\n    {\n        'completed': (bool) true if download is completed,\n        'file_name': (str) name of file,\n        'download_directory': (str) download directory,\n        'points_paid': (float) credit paid to download file,\n        'stopped': (bool) true if download is stopped,\n        'stream_hash': (str) stream hash of file,\n        'stream_name': (str) stream name,\n        'suggested_file_name': (str) suggested file name,\n        'sd_hash': (str) sd hash of file,\n        'name': (str) name claim attached to file\n        'outpoint': (str) claim outpoint attached to file\n        'claim_id': (str) claim ID attached to file,\n        'download_path': (str) download path of file,\n        'mime_type': (str) mime type of file,\n        'key': (str) key attached to file,\n        'total_bytes': (int) file size in bytes, None if full_status is false\n        'written_bytes': (int) written size in bytes\n        'message': (str), None if full_status is false\n        'metadata': (dict) Metadata dictionary\n    }", 
            "title": "get"
        }, 
        {
            "location": "/cli/#get_availability", 
            "text": "Get stream availability for lbry uri\n\nUsage:\n    get_availability ( uri  | --uri= uri ) [ sd_timeout  | --sd_timeout= sd_timeout ]\n                     [ peer_timeout  | --peer_timeout= peer_timeout ]\n\nOptions:\n     sd_timeout , --sd_timeout= sd_timeout         : sd blob download timeout\n     peer_timeout , --peer_timeout= peer_timeout   : how long to look for peers\n\nReturns:\n    (float) Peers per blob / total blobs", 
            "title": "get_availability"
        }, 
        {
            "location": "/cli/#help", 
            "text": "Return a useful message for an API command\n\nUsage:\n    help [ command  | --command= command ]\n\nOptions:\n     command , --command= command   : command to retrieve documentation for", 
            "title": "help"
        }, 
        {
            "location": "/cli/#peer_list", 
            "text": "Get peers for blob hash\n\nUsage:\n    peer_list ( blob_hash  | --blob_hash= blob_hash ) [ timeout  | --timeout= timeout ]\n\nOptions:\n     timeout , --timeout= timeout   : peer search timeout in seconds\n\nReturns:\n    (list) List of contacts", 
            "title": "peer_list"
        }, 
        {
            "location": "/cli/#publish", 
            "text": "Make a new name claim and publish associated data to lbrynet,\nupdate over existing claim if user already has a claim for name.\n\nFields required in the final Metadata are:\n    'title'\n    'description'\n    'author'\n    'language'\n    'license'\n    'nsfw'\n\nMetadata can be set by either using the metadata argument or by setting individual arguments\nfee, title, description, author, language, license, license_url, thumbnail, preview, nsfw,\nor sources. Individual arguments will overwrite the fields specified in metadata argument.\n\nUsage:\n    publish ( name  | --name= name ) ( bid  | --bid= bid ) [--metadata= metadata ]\n            [--file_path= file_path ] [--fee= fee ] [--title= title ]\n            [--description= description ] [--author= author ] [--language= language ]\n            [--license= license ] [--license_url= license_url ] [--thumbnail= thumbnail ]\n            [--preview= preview ] [--nsfw= nsfw ] [--sources= sources ]\n            [--channel_name= channel_name ] [--channel_id= channel_id ]\n            [--claim_address= claim_address ] [--change_address= change_address ]\n\nOptions:\n    --metadata= metadata           : ClaimDict to associate with the claim.\n    --file_path= file_path         : path to file to be associated with name. If provided,\n                                     a lbry stream of this file will be used in 'sources'.\n                                     If no path is given but a sources dict is provided,\n                                     it will be used. If neither are provided, an\n                                     error is raised.\n    --fee= fee                     : Dictionary representing key fee to download content:\n                                      {\n                                        'currency': currency_symbol,\n                                        'amount': float,\n                                        'address': str, optional\n                                      }\n                                      supported currencies: LBC, USD, BTC\n                                      If an address is not provided a new one will be\n                                      automatically generated. Default fee is zero.\n    --title= title                 : title of the publication\n    --description= description     : description of the publication\n    --author= author               : author of the publication\n    --language= language           : language of the publication\n    --license= license             : publication license\n    --license_url= license_url     : publication license url\n    --thumbnail= thumbnail         : thumbnail url\n    --preview= preview             : preview url\n    --nsfw= nsfw                   : title of the publication\n    --sources= sources             : {'lbry_sd_hash':sd_hash} specifies sd hash of file\n    --channel_name= channel_name   : name of the publisher channel name in the wallet\n    --channel_id= channel_id       : claim id of the publisher channel, does not check\n                                     for channel claim being in the wallet. This allows\n                                     publishing to a channel where only the certificate\n                                     private key is in the wallet.\n   --claim_address= claim_address  : address where the claim is sent to, if not specified\n                                     new address wil automatically be created\n\nReturns:\n    (dict) Dictionary containing result of the claim\n    {\n        'tx' : (str) hex encoded transaction\n        'txid' : (str) txid of resulting claim\n        'nout' : (int) nout of the resulting claim\n        'fee' : (float) fee paid for the claim transaction\n        'claim_id' : (str) claim ID of the resulting claim\n    }", 
            "title": "publish"
        }, 
        {
            "location": "/cli/#report_bug", 
            "text": "Report a bug to slack\n\nUsage:\n    report_bug ( message  | --message= message )\n\nReturns:\n    (bool) true if successful", 
            "title": "report_bug"
        }, 
        {
            "location": "/cli/#resolve", 
            "text": "Resolve given LBRY URIs\n\nUsage:\n    resolve [-f] ( uri  | --uri= uri ) [ uris ...]\n\nOptions:\n    -f  : force refresh and ignore cache\n\nReturns:\n    Dictionary of results, keyed by uri\n    ' uri ': {\n            If a resolution error occurs:\n            'error': Error message\n\n            If the uri resolves to a channel or a claim in a channel:\n            'certificate': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}],\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n\n            If the uri resolves to a channel:\n            'claims_in_channel': (int) number of claims in the channel,\n\n            If the uri resolves to a claim:\n            'claim': {\n                'address': (str) claim address,\n                'amount': (float) claim amount,\n                'effective_amount': (float) claim amount including supports,\n                'claim_id': (str) claim id,\n                'claim_sequence': (int) claim sequence number,\n                'decoded_claim': (bool) whether or not the claim value was decoded,\n                'height': (int) claim height,\n                'depth': (int) claim depth,\n                'has_signature': (bool) included if decoded_claim\n                'name': (str) claim name,\n                'channel_name': (str) channel name if claim is in a channel\n                'supports: (list) list of supports [{'txid': (str) txid,\n                                                     'nout': (int) nout,\n                                                     'amount': (float) amount}]\n                'txid': (str) claim txid,\n                'nout': (str) claim nout,\n                'signature_is_valid': (bool), included if has_signature,\n                'value': ClaimDict if decoded, otherwise hex string\n            }\n    }", 
            "title": "resolve"
        }, 
        {
            "location": "/cli/#resolve_name", 
            "text": "Resolve stream info from a LBRY name\n\nUsage:\n    resolve_name  name  [-f]\n\nOptions:\n    -f  : force refresh and do not check cache\n\nReturns:\n    (dict) Metadata dictionary from name claim, None if the name is not\n            resolvable", 
            "title": "resolve_name"
        }, 
        {
            "location": "/cli/#routing_table_get", 
            "text": "Get DHT routing information\n\nUsage:\n    routing_table_get\n\nReturns:\n    (dict) dictionary containing routing and contact information\n    {\n         buckets : {\n             bucket index : [\n                {\n                     address : (str) peer address,\n                     node_id : (str) peer node id,\n                     blobs : (list) blob hashes announced by peer\n                }\n            ]\n        },\n         contacts : (list) contact node ids,\n         blob_hashes : (list) all of the blob hashes stored by peers in the list of buckets,\n         node_id : (str) the local dht node id\n    }", 
            "title": "routing_table_get"
        }, 
        {
            "location": "/cli/#settings_get", 
            "text": "Get daemon settings\n\nUsage:\n    settings_get\n\nReturns:\n    (dict) Dictionary of daemon settings\n    See ADJUSTABLE_SETTINGS in lbrynet/conf.py for full list of settings", 
            "title": "settings_get"
        }, 
        {
            "location": "/cli/#settings_set", 
            "text": "Set daemon settings\n\nUsage:\n    settings_set [ download_directory  | --download_directory= download_directory ]\n                 [ data_rate  | --data_rate= data_rate ]\n                 [ download_timeout  | --download_timeout= download_timeout ]\n                 [ peer_port  | --peer_port= peer_port ]\n                 [ max_key_fee  | --max_key_fee= max_key_fee ]\n                 [ disable_max_key_fee  | --disable_max_key_fee= disable_max_key_fee ]\n                 [ use_upnp  | --use_upnp= use_upnp ]\n                 [ run_reflector_server  | --run_reflector_server= run_reflector_server ]\n                 [ cache_time  | --cache_time= cache_time ]\n                 [ reflect_uploads  | --reflect_uploads= reflect_uploads ]\n                 [ share_usage_data  | --share_usage_data= share_usage_data ]\n                 [ peer_search_timeout  | --peer_search_timeout= peer_search_timeout ]\n                 [ sd_download_timeout  | --sd_download_timeout= sd_download_timeout ]\n                 [ auto_renew_claim_height_delta \n                    | --auto_renew_claim_height_delta= auto_renew_claim_height_delta]\n\nOptions:\n     download_directory , --download_directory= download_directory   : (str)\n     data_rate , --data_rate= data_rate                              : (float), 0.0001\n     download_timeout , --download_timeout= download_timeout         : (int), 180\n     peer_port , --peer_port= peer_port                              : (int), 3333\n     max_key_fee , --max_key_fee= max_key_fee    : (dict) maximum key fee for downloads,\n                                                    in the format: {\n                                                         currency :  currency_symbol ,\n                                                         amount :  amount \n                                                    }. In the CLI, it must be an escaped\n                                                    JSON string\n                                                    Supported currency symbols:\n                                                        LBC\n                                                        BTC\n                                                        USD\n     disable_max_key_fee , --disable_max_key_fee= disable_max_key_fee  : (bool), False\n     use_upnp , --use_upnp= use_upnp             : (bool), True\n     run_reflector_server , --run_reflector_server= run_reflector_server   : (bool), False\n     cache_time , --cache_time= cache_time   : (int), 150\n     reflect_uploads , --reflect_uploads= reflect_uploads   : (bool), True\n     share_usage_data , --share_usage_data= share_usage_data   : (bool), True\n     peer_search_timeout , --peer_search_timeout= peer_search_timeout   : (int), 3\n     sd_download_timeout , --sd_download_timeout= sd_download_timeout   : (int), 3\n     auto_renew_claim_height_delta ,\n        --auto_renew_claim_height_delta= auto_renew_claim_height_delta  : (int), 0\n        claims set to expire within this many blocks will be\n        automatically renewed after startup (if set to 0, renews\n        will not be made automatically)\n\n\nReturns:\n    (dict) Updated dictionary of daemon settings", 
            "title": "settings_set"
        }, 
        {
            "location": "/cli/#status", 
            "text": "Get daemon status\n\nUsage:\n    status [-s] [-d]\n\nOptions:\n    -s  : include session status in results\n    -d  : include dht network and peer status\n\nReturns:\n    (dict) lbrynet-daemon status\n    {\n        'lbry_id': lbry peer id, base58\n        'installation_id': installation id, base58\n        'is_running': bool\n        'is_first_run': bool\n        'startup_status': {\n            'code': status code\n            'message': status message\n        },\n        'connection_status': {\n            'code': connection status code\n            'message': connection status message\n        },\n        'blockchain_status': {\n            'blocks': local blockchain height,\n            'blocks_behind': remote_height - local_height,\n            'best_blockhash': block hash of most recent block,\n        },\n\n        If given the session status option:\n            'session_status': {\n                'managed_blobs': count of blobs in the blob manager,\n                'managed_streams': count of streams in the file manager\n                'announce_queue_size': number of blobs currently queued to be announced\n                'should_announce_blobs': number of blobs that should be announced\n            }\n\n        If given the dht status option:\n            'dht_status': {\n                'kbps_received': current kbps receiving,\n                'kbps_sent': current kdps being sent,\n                'total_bytes_sent': total bytes sent\n                'total_bytes_received': total bytes received\n                'queries_received': number of queries received per second\n                'queries_sent': number of queries sent per second\n                'recent_contacts': count of recently contacted peers\n                'unique_contacts': count of unique peers\n            }\n    }", 
            "title": "status"
        }, 
        {
            "location": "/cli/#stream_cost_estimate", 
            "text": "Get estimated cost for a lbry stream\n\nUsage:\n    stream_cost_estimate  uri  [ size  | --size= size ]\n\nOptions:\n     size , --size= size   : stream size in bytes. if provided an sd blob won't be\n                             downloaded.\n\nReturns:\n    (float) Estimated cost in lbry credits, returns None if uri is not\n        resolveable", 
            "title": "stream_cost_estimate"
        }, 
        {
            "location": "/cli/#transaction_list", 
            "text": "List transactions belonging to wallet\n\nUsage:\n    transaction_list [-t]\n\nOptions:\n    -t  : Include claim tip information\n\nReturns:\n    (list) List of transactions, where is_tip is null by default,\n     and set to a boolean if include_tip_info is true\n\n    {\n         claim_info : (list) claim info if in txn [{ amount : (float) claim amount,\n                                                     claim_id : (str) claim id,\n                                                     claim_name : (str) claim name,\n                                                     nout : (int) nout}],\n         confirmations : (int) number of confirmations for the txn,\n         date : (str) date and time of txn,\n         fee : (float) txn fee,\n         support_info : (list) support info if in txn [{ amount : (float) support amount,\n                                                         claim_id : (str) claim id,\n                                                         claim_name : (str) claim name,\n                                                         is_tip : (null) default,\n                                                        (bool) if include_tip_info is true,\n                                                         nout : (int) nout}],\n         timestamp : (int) timestamp,\n         txid : (str) txn id,\n         update_info : (list) update info if in txn [{ amount : (float) updated amount,\n                                                       claim_id : (str) claim id,\n                                                       claim_name : (str) claim name,\n                                                       nout : (int) nout}],\n         value : (float) value of txn\n    }", 
            "title": "transaction_list"
        }, 
        {
            "location": "/cli/#transaction_show", 
            "text": "Get a decoded transaction from a txid\n\nUsage:\n    transaction_show ( txid  | --txid= txid )\n\nReturns:\n    (dict) JSON formatted transaction", 
            "title": "transaction_show"
        }, 
        {
            "location": "/cli/#utxo_list", 
            "text": "List unspent transaction outputs\n\nUsage:\n    utxo_list\n\nReturns:\n    (list) List of unspent transaction outputs (UTXOs)\n    [\n        {\n             address : (str) the output address\n             amount : (float) unspent amount\n             height : (int) block height\n             is_claim : (bool) is the tx a claim\n             is_coinbase : (bool) is the tx a coinbase tx\n             is_support : (bool) is the tx a support\n             is_update : (bool) is the tx an update\n             nout : (int) nout of the output\n             txid : (str) txid of the output\n        },\n        ...\n    ]", 
            "title": "utxo_list"
        }, 
        {
            "location": "/cli/#version", 
            "text": "Get lbry version information\n\nUsage:\n    version\n\nReturns:\n    (dict) Dictionary of lbry version information\n    {\n        'build': (str) build type (e.g.  dev ,  rc ,  release ),\n        'ip': (str) remote ip, if available,\n        'lbrynet_version': (str) lbrynet_version,\n        'lbryum_version': (str) lbryum_version,\n        'lbryschema_version': (str) lbryschema_version,\n        'os_release': (str) os release string\n        'os_system': (str) os name\n        'platform': (str) platform string\n        'processor': (str) processor type,\n        'python_version': (str) python version,\n    }", 
            "title": "version"
        }, 
        {
            "location": "/cli/#wallet_balance", 
            "text": "Return the balance of the wallet\n\nUsage:\n    wallet_balance [ address  | --address= address ] [-u]\n\nOptions:\n     address   :  If provided only the balance for this address will be given\n    -u         :  Include unconfirmed\n\nReturns:\n    (float) amount of lbry credits in wallet", 
            "title": "wallet_balance"
        }, 
        {
            "location": "/cli/#wallet_is_address_mine", 
            "text": "Checks if an address is associated with the current wallet.\n\nUsage:\n    wallet_is_address_mine ( address  | --address= address )\n\nReturns:\n    (bool) true, if address is associated with current wallet", 
            "title": "wallet_is_address_mine"
        }, 
        {
            "location": "/cli/#wallet_list", 
            "text": "List wallet addresses\n\nUsage:\n    wallet_list\n\nReturns:\n    List of wallet addresses", 
            "title": "wallet_list"
        }, 
        {
            "location": "/cli/#wallet_new_address", 
            "text": "Generate a new wallet address\n\nUsage:\n    wallet_new_address\n\nReturns:\n    (str) New wallet address in base58", 
            "title": "wallet_new_address"
        }, 
        {
            "location": "/cli/#wallet_prefill_addresses", 
            "text": "Create new addresses, each containing `amount` credits\n\nUsage:\n    wallet_prefill_addresses [--no_broadcast]\n                             ( num_addresses  | --num_addresses= num_addresses )\n                             ( amount  | --amount= amount )\n\nReturns:\n    (dict) the resulting transaction", 
            "title": "wallet_prefill_addresses"
        }, 
        {
            "location": "/cli/#wallet_public_key", 
            "text": "Get public key from wallet address\n\nUsage:\n    wallet_public_key ( address  | --address= address )\n\nReturns:\n    (list) list of public keys associated with address.\n        Could contain more than one public key if multisig.", 
            "title": "wallet_public_key"
        }, 
        {
            "location": "/cli/#wallet_send", 
            "text": "Send credits. If given an address, send credits to it. If given a claim id, send a tip\nto the owner of a claim specified by uri. A tip is a claim support where the recipient\nof the support is the claim address for the claim being supported.\n\nUsage:\n    wallet_send ( amount  | --amount= amount )\n                (( address  | --address= address ) | ( claim_id  | --claim_id= claim_id ))\n\nReturn:\n    If sending to an address:\n    (bool) true if payment successfully scheduled\n\n    If sending a claim tip:\n    (dict) Dictionary containing the result of the support\n    {\n        txid : (str) txid of resulting support claim\n        nout : (int) nout of the resulting support claim\n        fee : (float) fee paid for the transaction\n    }", 
            "title": "wallet_send"
        }, 
        {
            "location": "/cli/#wallet_unused_address", 
            "text": "Return an address containing no balance, will create\na new address if there is none.\n\nUsage:\n    wallet_unused_address\n\nReturns:\n    (str) Unused wallet address in base58", 
            "title": "wallet_unused_address"
        }
    ]
}